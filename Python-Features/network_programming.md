# Python 其他内容


### 156.TCP 和 UDP 的区别？
1. TCP面向连接，UDP无连接；
2. TCP基于字节流，UDP基于报文；
3. TCP有流控制和拥塞控制，UDP的吞吐量只取决于数据生成速率、传输带宽；
4. TCP可靠按序交付，UDP尽可能最大交付且乱序；
5. TCP全双工点对点通信，UDP可以一对一、一对多、多对一、多对多。


### 157.简要介绍三次握手和四次挥手
TCP通过三次握手来建立连接，通过四次挥手来断开连接。  
* **为什么是3次握手：**
	* 3次握手是连接双方都确认自己和对方有收发能力的最少握手次数；
	* 若只握手2次，服务器端在接收到客户端的请求就打开连接，可能收到网络中的失效请求而误打开连接，造成资源浪费；
	* 若第3次失败，服务器端会关闭连接，防止SYN洪泛攻击。
* **为什么是4次挥手：**
当服务器端收到客户端的关闭请求时，先响应ACK信号表示自己收到了客户端的请求，再将自己需要发给客户端的数据发完，最后再发送FIN信号表示自己的数据传输完毕。ACK与FIN分开响应使得挥手比握手（服务器的ACK和SYN同时发送回客户端）多了一次。
* **为什么客户端要等待2MSL再关闭连接**：
	* 为了防止客户端的最后一个ACK没有到达服务器，使得服务器端一直未关闭连接。此时客户端还能重新发送ACK给服务器，并重启2MSL计时器；
	* 为了让这次连接中的所有消息都消失在网络中，防止新的连接收到旧的失效请求。


### 158.什么是粘包？ socket 中造成粘包的原因是什么？ 哪些情况会发生粘包现象？
**粘包**：多个数据包被存储与连续内存中，在对数据包进行读取时无法确定数据包的边界，而采用一个估测值来进行数据读出。此时若双方的size不一致则会导致发送方的若干数据包到接收方粘成一团，从缓冲区看，数据包头尾紧相连。

**原因**：
	* 发送方粘包是由TCP协议引起的，若连续几次的数据都很少，TCP会合并发送，此时接收方就收到了粘包数据。
	* 接收方粘包是由于接收进程不及时取走数据包。接收方将接收到的数据包放入缓存，若新数据包到来时旧数据包尚未取走，则此时进程按预先设定的大小取走包就会取到粘包数据。
**处理**：接收方建立预处理线程，将接收到的包分开。